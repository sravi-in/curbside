// Package curbside is a client implementation for API server
// http://challenge.shopcurbside.com/.
//
// Each request sent to API server needs a valid Session header,
// which can be generated by GetSession or a SessGen which
// concurrently generates next few SessRsp:
//
//     // Use sess as a Session header for upto SessReuseCount requests
//     sess, err := curbside.GetSession()
//     ...
//     // Start a session generator with 6 workers, consume as much as required
//     // and stop. SessGen returns the same session for upto SessReuseCount
//     sg := curbside.NewSessGen(6)
//     srsp := <-sg.Sess
//     sg.Stop()
//
// The API server hosts a tree with each node identified by an ID. The Response
// represents a single node which can be queried by invoking Query:
//
//     rsp, err := curbside.Query(session, id)
//
// Or walk over the entire tree from the startID in breadth first order revealing
// the secret:
//
//     secret, err := curbside.RevealSecret(startID)
//
package curbside

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"
)

//const SessURL = "http://challenge.shopcurbside.com/get-session"

const SessURL = "http://localhost:8000/get-session"
const SessReuseCount = 10

// The SessGen holds a channel that delivers a stream of SessRsp until
// cancelled by its Stop method.
type SessGen struct {
	Sess chan SessRsp
	next chan SessRsp
	stop chan struct{}
	wg   sync.WaitGroup
}

// The SessRsp type holds a valid Session header string or an error
type SessRsp struct {
	// Sess is a valid Session header string, if Err is nil.
	// The Session header is required in each request sent to
	// API server
	Sess string
	Err  error
}

// NewSessGen starts and returns a new SessGen with specified numWorkers
// generating Session header concurrently. The SessGen needs to be
// explicitly stopped by calling its Stop method
func NewSessGen(numWorkers int) *SessGen {
	var sg SessGen
	sg.next = make(chan SessRsp)
	sg.stop = make(chan struct{})
	sg.Sess = make(chan SessRsp)

	sg.wg.Add(numWorkers + 1)

	// Generate and keep upto next numWorkers session IDs
	for i := 0; i < numWorkers; i++ {
		go sg.genNext()
	}

	// Aggregate and return same Session ID for SessReuseCount requests
	go sg.genSess()

	return &sg
}

// genNext generates a new Session and sends on next channel, unless a stop
// event is received
func (sg *SessGen) genNext() {
	defer sg.wg.Done()
	for {
		sess, err := GetSession()
		select {
		case <-sg.stop:
			return
		case sg.next <- SessRsp{sess, err}:
		}
	}
}

func (sg *SessGen) genSess() {
	var rsp SessRsp
	var ok bool
	next := sg.next
	var current chan SessRsp
	i := SessReuseCount
	defer sg.wg.Done()
	for {
		select {
		case rsp, ok = <-next:
			if !ok {
				return
			}
			i = 0
			current = sg.Sess
			next = nil
		case current <- rsp:
			i++
			if i == SessReuseCount {
				current = nil
				next = sg.next
			}
		case <-sg.stop:
			return
		}
	}
}

// Stop turns off the SessGen from generating SessRsp and closes the channel
func (sg *SessGen) Stop() {
	close(sg.stop)
	sg.wg.Wait()
	close(sg.next)
	close(sg.Sess)
	// consume channel to prevent leaks
	for range sg.next {
	}
	for range sg.Sess {
	}
}

// GetSession performs a HTTP GET request to SessURL and returns the response
// as string. It returns an error on failure.
func GetSession() (string, error) {
	resp, err := http.Get(SessURL)
	if err != nil {
		return "", fmt.Errorf("get session: %v", err)
	}

	defer resp.Body.Close()
	sess, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", fmt.Errorf("reading rsp from %s: %v", SessURL, err)
	}

	return string(sess), nil
}
